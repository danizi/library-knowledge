**同步（Synchronous）**<br>
任务按「顺序执行」，执行完一个任务后，才能执行下一个任务；在当前任务未完成前，程序会「阻塞等待」，无法做其他事。<br>

**异步（Asynchronous）**<br>
任务不按固定顺序执行，发起一个任务后，程序不需要「阻塞等待」，可以立刻去执行其他任务；当该任务完成后，会通过「回调 / 通知」的方式告知程序处理结果。<br>

**阻塞**<br>
当程序发起一个任务后，在该任务完成前，当前线程会被 “卡住”（暂停执行），无法做任何其他事，直到任务返回结果。<br>

**非阻塞**<br>
当程序发起一个任务后，当前线程不会暂停，可以立刻去执行其他代码；任务的执行在 “后台” 进行，完成后通过通知 / 回调告知程序。<br>

**并发(Concurrency)**<br>
多个任务在同一「时间段」内交替执行，但在同一「时间点」只有一个任务在执行。<br>

**并行（Parallelism）**<br>
多个任务在同一「时间点」同时执行，每个任务有独立的执行单元（如多个 CPU 核心）。<br>

**进程（process）**<br>
进程是资源分配的最小单位、进程间不共享内存，每个进程拥有自己独立的内存、进程间可以通过信号、信号量、共享内存、管道、队列等来通信、新开进程开销大，并且 CPU 切换进程成本也大、进程由操作系统调度、多进程方式比多线程更加稳定<br>
  
**线程（thread）**<br>
线程是程序执行流的最小单位、线程是来自于进程的，一个进程下面可以开多个线程、每个线程都有自己一个栈，不共享栈，但多个线程能共享同一个属于进程的堆、线程因为是在同一个进程内的，可以共享内存、线程也是由操作系统调度，线程是 CPU 调度的最小单位、新开线程开销小于进程，CPU 在切换线程成本也小于进程、某个线程发生致命错误会导致整个进程崩溃、线程间读写变量存在锁的问题处理起来相对麻烦<br>
  
**协程（coroutine）**<br>
对于操作系统来说只有进程和线程，协程的控制由应用程序显式调度，非抢占式的、协程的执行最终靠的还是线程，应用程序来调度协程选择合适的线程来获取执行权、切换非常快，成本低。一般占用栈大小远小于线程（协程 KB 级别，线程 MB 级别），所以可以开更多的协程、协程比线程更轻量级<br>


同步 / 异步：描述「任务的发起和结果获取方式」（主动等 vs 被动通知）。
阻塞 / 非阻塞：描述「等待结果时的线程状态」（卡着等 vs 边干边等）。
并发 / 并行：描述「多任务的执行方式」（交替执行 vs 同时执行）。
